# Uniapp 企业级模板 - 核心功能使用指南

本文档介绍项目中几个核心功能的设计思路和使用方法。

---

## 1. 请求取消机制

### 为什么需要？

- 用户快速切换页面时，之前的请求还在进行，可能导致内存泄漏
- 搜索场景下，用户连续输入会发起多个请求，旧请求返回可能覆盖新数据
- 列表页快速翻页，旧页数据可能覆盖新页数据

### 使用方法

```javascript
import { http } from '@/api/core/request.js';

// 1. 取消前一个相同请求（搜索场景推荐）
const res = await http.get('/api/search', { keyword: 'test' }, {
  cancelPrevious: true  // 自动取消前一个相同 URL+参数 的请求
});

// 2. 页面卸载时取消请求
import { onUnmounted } from 'vue';

onUnmounted(() => {
  http.cancelRequestsByUrl('/api/user/list');  // 取消指定 URL 的请求
  // 或者
  http.cancelAllRequests();  // 取消所有请求
});

// 3. 手动取消单个请求
const requestId = 'GET_/api/user_{"id":1}';  // 格式：METHOD_URL_PARAMS
http.cancelRequest(requestId);
```

### 实现原理

```javascript
// 使用 Map 存储所有进行中的请求
const requestTaskMap = new Map();

// 生成唯一请求 ID
const generateRequestId = ({ url, method, data }) => {
  return `${method}_${url}_${JSON.stringify(data)}`;
};

// 取消请求
export function cancelRequest(requestId) {
  const task = requestTaskMap.get(requestId);
  if (task) {
    task.abort();  // uni.request 返回的 task 支持 abort()
    requestTaskMap.delete(requestId);
  }
}
```

---

## 2. Token 管理

### 功能特性

- 自动刷新（可配置开关）
- 并发控制（多个请求同时触发刷新时只执行一次）
- 请求队列（刷新期间的请求自动排队等待）
- 防重复跳转登录页

### 配置

```javascript
// src/config/token.js
export const AUTO_REFRESH_ENABLED = false;  // 是否启用自动刷新
export const BUFFER_TIME = 5 * 60 * 1000;   // 提前 5 分钟刷新
export const REDIRECT_DELAY = 3000;          // 防重复跳转间隔
```

### 使用方法

```javascript
import { tokenManager } from '@/auth/tokenManager.js';

// 保存 token
tokenManager.saveToken({
  userId: '123',
  accessToken: 'xxx',
  refreshToken: 'yyy',
  expiresTime: Date.now() + 7200000  // 2小时后过期
});

// 获取有效 token（自动处理刷新）
const token = await tokenManager.getValidToken();

// 检查登录状态
if (tokenManager.isLoggedIn()) {
  // 已登录
}

// 清除 token
tokenManager.clearToken();

// 动态开关自动刷新
tokenManager.setAutoRefresh(true);
```

### 并发控制原理

```javascript
async refreshToken() {
  // 如果已经在刷新中，返回同一个 Promise
  if (this.refreshPromise) {
    return this.refreshPromise;
  }
  
  this.refreshPromise = this._performRefresh();
  
  try {
    const result = await this.refreshPromise;
    this._processPendingQueue(null, result);  // 处理排队的请求
    return result;
  } finally {
    this.refreshPromise = null;
  }
}
```

---

## 3. 多环境切换

### 支持的环境

| 环境 | 说明 | API 地址变量 |
|------|------|-------------|
| local | 本地开发 | VITE_LOCAL_API_BASE_URL |
| dev | 测试环境 | VITE_DEV_API_BASE_URL |
| prod | 生产环境 | VITE_PROD_API_BASE_URL |

### 配置环境变量

```bash
# .env
VITE_LOCAL_API_BASE_URL=http://localhost:3000
VITE_DEV_API_BASE_URL=https://api-dev.example.com
VITE_PROD_API_BASE_URL=https://api.example.com
```

### 使用方法

```javascript
// 控制台切换环境（体验版/开发版可用）
switchEnv('dev')    // 切换到测试环境
switchEnv('prod')   // 切换到生产环境
switchEnv('local')  // 切换到本地环境

// 代码中获取环境信息
import { getCurrentEnvInfo, getAPIBaseURL } from '@/utils/env.js';

const envInfo = getCurrentEnvInfo();
// { type: 'dev', name: '测试环境', isDev: true, canSwitch: true }

const baseURL = getAPIBaseURL();
// https://api-dev.example.com
```

### 安全机制

线上正式版本会自动锁定 prod 环境，无法切换：

```javascript
function isReleaseVersion() {
  const accountInfo = wx.getAccountInfoSync();
  return accountInfo.miniProgram?.envVersion === 'release';
}
```

---

## 4. 页面缓存

### 使用场景

- 页面间传递复杂数据（对象、数组）
- 解决 URL 参数长度限制（小程序 URL 限制 2KB）
- 临时保存页面状态

### 使用方法

```javascript
import { savePageCache, getPageCache, clearPageCache } from '@/utils/cache.js';

// 页面 A：保存数据后跳转
savePageCache('/pages/order/detail', {
  orderId: 123,
  items: [{ id: 1, name: '商品1' }, { id: 2, name: '商品2' }],
  extra: { /* 更多数据 */ }
});
uni.navigateTo({ url: '/pages/order/detail' });

// 页面 B：获取缓存数据
const data = getPageCache('/pages/order/detail');
// { orderId: 123, items: [...], timestamp: 1234567890 }

// 使用完后清理
clearPageCache('/pages/order/detail');
```

### 自动获取当前页面路径

```javascript
// 不传路径时，自动使用当前页面路径
savePageCache(null, { key: 'value' });
const data = getPageCache();  // 自动获取当前页面的缓存
```

---

## 5. 请求便捷方法

### 基本用法

```javascript
import { http } from '@/api/core/request.js';

// GET 请求
const res = await http.get('/api/user/info', { id: 123 });

// POST 请求
const res = await http.post('/api/user/update', { name: '张三' });

// PUT / DELETE
const res = await http.put('/api/user/123', { name: '李四' });
const res = await http.delete('/api/user/123');
```

### 配置选项

```javascript
const res = await http.post('/api/data', data, {
  loading: false,        // 不显示 loading
  loadingText: '提交中', // 自定义 loading 文字
  showError: false,      // 不显示错误提示
  cancelPrevious: true,  // 取消前一个相同请求
});
```

### 错误处理

```javascript
try {
  const res = await http.get('/api/data');
  // res.code === 0 表示成功
} catch (error) {
  if (error.code === 'REQUEST_CANCELLED') {
    // 请求被取消，通常不需要处理
    return;
  }
  // 其他错误
  console.error(error.msg);
}
```

---

## 6. 工程化命令

```bash
# 开发
pnpm run dev:mp-weixin   # 微信小程序
pnpm run dev:h5          # H5

# 构建
pnpm run build:mp-weixin # 微信小程序
pnpm run build:h5        # H5

# 代码提交（中文提示）
git add .
npx cz   # 或 pnpm run commit

# 代码检查
pnpm run lint
```

---

## 最佳实践

1. **页面卸载时取消请求** - 避免内存泄漏和数据错乱
2. **搜索场景使用 cancelPrevious** - 避免旧结果覆盖新结果
3. **复杂参数用页面缓存** - 不要拼接超长 URL
4. **线上环境自动锁定** - 不用担心误切环境
5. **使用 npx cz 提交代码** - 保持提交信息规范
